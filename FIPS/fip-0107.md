---
fip: "0107"
title: Implicit Messages in Block Receipts
author: "Rod Vagg (@rvagg)"
discussions-to: https://github.com/filecoin-project/FIPs/discussions/1149
status: Last Call
review-period-end: 2025-07-01
type: Technical
category: Core
created: 2025-05-14
spec-sections:
  - 2.8.18.32 Receipts
  - 2.8.21.42 Implicit messages
requires: N/A
replaces: N/A
---

# FIP-0107: Implicit Messages in Block Receipts

## Simple Summary

This FIP adds implicit messages (cron and reward) to block receipts, allowing their execution to be inspected and events generated by system operations to be properly captured and tracked in the chain. A primary benefit of this is better visibility into sector lifecycles. Additionally, it simplifies determining which messages actually executed without needing to deduplicate messages across parent tipset blocks. The FIP also extends the `MessageReceipt` structure to include codec information for return data, enabling proper interpretation of execution results.

## Abstract

Currently, Filecoin's cron and reward operations execute via implicit messages inserted during the execution of a tipset. Execution of these messages produces events, but these events cannot be captured properly since execution receipts are not captured and referenced by the chain. This proposal addresses these limitations by:

1. Formalising implicit messages such that they can be linked on the chain and stored in a node's blockstore;
2. Including links to the executed message in the `MessageReceipt` object generated after execution;
3. Including `MessageReceipt` objects for implicit messages in the `ParentMessageReceipt`s array in the `BlockHeader`; and
4. Adding a codec identifier field to `MessageReceipt` that indicates how to decode the return data bytes.

These changes enable proper event capture for system operations, particularly improving sector lifecycle tracking, simplify message deduplication across tipsets, and afford the ability to more completely observe and correctly interpret the execution of a tipset.

## Change Motivation

The existing protocol has several critical gaps that this FIP addresses:

1. **Lost System Events**: Cron and reward operations produce important events (particularly for sector lifecycle tracking), but since they use implicit messages without proper receipts, these events are lost. This forces users and tools to perform complex analysis of state diffs between epochs to understand what happened, particularly for tracking sector terminations.

2. **Message Deduplication Complexity**: When determining which messages actually executed in a tipset, clients must currently perform complex deduplication of messages across all blocks in the parent tipset. Direct access to executed message receipts simplifies this process significantly.

3. **Lost Codec Information**: When messages return data, the FVM discards the codec information that would indicate how to interpret the return bytes. This makes it difficult for generic tooling to decode and display return data without prior knowledge of the actor implementation or using error-prone heuristics.

Current challenges include:

1. Sector lifecycle events (especially terminations) are not easily visible through events or message receipts
2. External APIs struggle to provide comprehensive sector tracking information
3. Tooling for inspecting state changes between tipsets is unnecessarily complex and difficult to interpret
4. Important system operations lack visibility in the chain's event system
5. Message execution results cannot be generically decoded without specialised knowledge about actor implementations

This change is necessary to provide complete visibility into chain operations, simplify tracking of sector lifecycles and other system events, and enable more robust tooling for transaction analysis.

## Specification

### MessageReceipt Structure Modification

The `MessageReceipt` structure will be modified to include both a reference to the executed message and codec information for the return data:

```go
type MessageReceipt struct {
    version      MessageReceiptVersion
    ExitCode     exitcode.ExitCode
    Return       []byte
    GasUsed      int64
    EventsRoot   *cid.Cid        // Root of Event AMT with bitwidth = EventAMTBitwidth
    IpldCodec    *uint64         // NEW: IPLD codec for interpreting Return bytes, nullable for backward compatibility
    Message      *cid.Cid        // NEW: Reference to the executed message, nullable for backward compatibility
}
```

Both new fields are nullable (pointers in Go, `Option`s in Rust) for backward compatibility. They are expected to be omitted for receipts prior to activation of this FIP but always be non-empty after activation of this FIP. The `EventsRoot` field was added in [FIP-0049](./fip-0049.md) and is similarly omitted prior to activation to that FIP.

### Implicit Message Definitions

Implicit messages must be encoded consistently to produce stable CIDs across all Filecoin nodes. The following definitions, currently used by Filecoin's reference implementation (Lotus) will be used:

#### Reward Messages

```go
rewardMessage := &types.Message{
   From:       builtin.SystemActorAddr,         // f00
   To:         reward.Address,                  // f02
   Nonce:      currentEpoch,
   Value:      0,
   GasFeeCap:  0,
   GasPremium: 0,
   GasLimit:   1 << 30,                         // 1_073_741_824
   Method:     reward.Methods.AwardBlockReward, // 2
   Params:     params,                          // reward params for this miner/block
}
```

#### Cron Messages

```go
cronMessage := &types.Message{
   To:         cron.Address,                         // f03
   From:       builtin.SystemActorAddr,              // f00
   Nonce:      currentEpoch,
   Value:      0,
   GasFeeCap:  0,
   GasPremium: 0,
   GasLimit:   buildconstants.BlockGasLimit * 10000, // 100 Trillion
   Method:     cron.Methods.EpochTick,               // 2
   Params:     nil,
}
```

#### Gas Limit Rationale

These gas limits serve as execution bounds for the individual messages and are not subject to block-level gas constraints. Unlike user messages, implicit messages do not contribute to or get limited by the block gas limit (`buildconstants.BlockGasLimit`). The gas limits specified in the message structure serve as the maximum gas that can be consumed during execution of that specific message. If gas accounting during message execution exceeds the message's gas limit, the message execution fails.

**Reward Message Gas Allocation**: The gas limit of approximately 1.07 billion provides substantial headroom for reward operations, which have predictable and bounded computational costs. Reward message execution involves adjusting the miner's vesting schedule with new rewards, unlocking any vested amounts in the process, and attempting to repay any existing fee debt. These operations have relatively consistent resource requirements with minimal variation across different execution contexts.

**Cron Message Gas Allocation**: The exceptionally high gas limit of 100 trillion addresses the inherently variable and potentially extensive computational requirements of cron operations. Cron execution encompasses critical network maintenance functions including deadline processing, early sector terminations, proof fee accounting, fault fee processing, vesting schedule management, and pledge adjustments. The computational cost of these operations varies significantly based on network state, particularly the number of sectors requiring processing and the complexity of state transitions occurring at epoch boundaries.

To manage these variable costs, protocol development has consistently prioritised efficiency improvements and cost reduction strategies. Where feasible, operations have been relocated from cron execution to userspace, as demonstrated in [FIP-0084](./fip-0084.md), which removed computationally expensive sector activations from the cron actor. Despite these optimisation efforts, the unpredictable nature of network state changes necessitates substantial gas headroom to ensure system-critical operations complete successfully under all network conditions.

In practice, actual gas consumption during cron execution typically remains well below this generous limit, reflecting both the effectiveness of ongoing optimisation efforts and the conservative approach taken to guarantee system reliability.

### Message Execution Order

Messages will be ordered as they currently are for tipset execution, and this order will now also be used to determine the order of receipts referenced in the `ParentMessageReceipts` list:

1. Previous null round cron messages (if any null rounds immediately prior to this tipset)
2. For each block in the tipset:
   - Messages in that block (excluding duplicates already executed from previous blocks in this tipset)
   - Reward message for that block
3. Cron message for the current epoch

### Block Structure Changes

- Implicit messages will NOT be included in the `Messages` list in block headers
- Implicit messages WILL be referenced in the `ParentMessageReceipts` list which is a single (not per-block) list for the entire parent tipset, ordered by execution
- Each tipset's receipts will reference *at least* one cron message, plus additional cron messages for preceding null rounds
- Each tipset's receipts will reference *exactly* one reward message per block in the parent tipset

#### Return Data Codec Handling

The FVM will maintain codec information from the execution return value and this will be included in the `MessageReceipt`. This allows external systems to properly decode the return data without requiring prior knowledge of the actor implementation.

IPLD codec codes used in this field are recorded in the [multicodec table](https://github.com/multiformats/multicodec/blob/master/table.csv) either with the `ipld` or `serialization` tag.

## Design Rationale

This design was chosen to minimise disruption to existing systems while providing complete visibility into system operations.

1. **Receipt linking**: Allows events to be properly associated with their originating messages rather than indirectly via the de-duplicated across-block list generated from parent blocks and allows us to insert implicit messages without needing to list them in a new block field.
2. **Execution ordering**: Maintains consistency with current execution semantics.
3. **Message specification**: Uses the existing Lotus implicit message format as a stable basis for all node implementations.
4. **Gas limit approach**: Maintains existing execution patterns while clarifying that implicit messages operate outside block gas limit constraints. This ensures system operations can complete successfully regardless of user message activity or network congestion.

### Storage Efficiency Assessment

The size impact is relatively modest compared to the value gained:
- Reward messages: approximately 40 bytes each (variable due to token amount byte sizes)
- Cron messages: exactly 27 bytes each
- MessageReceipt expansion: 45 bytes per receipt (from additional CID and codec fields)

### Return Data Codec Information

The addition of an IPLD codec field to `MessageReceipt` addresses a significant oversight in the original receipt design. When the FVM executes a message, the immediate return value includes both bytes and codec information, but the codec has historically been discarded before returning from the FVM execution call. This has several drawbacks:

1. **Loss of type information**: Without the codec, generic tooling cannot reliably interpret return data.
2. **Fragile decoding**: Clients must rely on heuristics or actor-specific knowledge to decode return data.
3. **Poor developer experience**: Building tools to inspect chain state becomes unnecessarily complex.

By preserving the codec information, we enable:
1. **Generic data inspection**: Chain explorers can correctly display return values without actor-specific handling.
2. **Improved error diagnostics**: Debugging tools can present execution results in human-readable format.
3. **Future-proofing**: As more complex return types are introduced, the codec field ensures proper interpretation.

The change to include the codec is minimal but impactful, adding just a single nullable integer field to the receipt structure.

## Backwards Compatibility

This change introduces several backwards incompatibilities:

1. **Receipt Structure Change**: The `MessageReceipt` structure modification requires updates to all code that directly accesses receipt fields; this change will take effect at the next epoch after the activation epoch of this FIP
2. **Message/Receipt Count Mismatch**: Code assuming `length(deduped parent messages) == length(receipts)` will break and must be updated to use receipts as the canonical list of messages executed and filter out implicit messages as required

### Storage Impact

Based on message sizes and typical network patterns:
- Cron messages: One or more per tipset (exactly 27 bytes each)
  - One cron message per tipset is guaranteed
  - Additional cron messages occur for null rounds
- Reward messages: One per block (approximately 40 bytes each)
  - The protocol targets 5 blocks per tipset, although actual average is lower
- Receipts: One per executed message (45 bytes additional per receipt)
  - Assuming roughly 100 unique executed messages per tipset
- Blockstore index overhead:
  - Each new message and receipt requires CID storage in the blockstore index
  - This creates additional overhead beyond just the raw message sizes

For a typical day with 2880 epochs and assuming 5 blocks per tipset and 100 messages:
- Additional raw data per tipset:
  - Cron: 27 bytes (minimum)
  - Rewards: 5 × 40 = 200 bytes
  - Receipt expansion: 100 × 45 = 4500 bytes
  - Plus blockstore indexing overhead (unquantified but significant)
- Adding approximately 13 MiB per day in block data; plus additional data for blockstore accounting

**Event Storage (Optional)**

For nodes that opt to save events:
- Additional event data from cron and reward messages (in the range of 20-100 bytes per event)
- Additional AMT blocks to store the events
- Additional blockstore entries for event CIDs
- Notable sector lifecycle events (e.g., sector-terminated) become properly trackable

This represents an optional storage increase for nodes that choose to track events, with the benefit of full sector lifecycle visibility.

**Snapshot Impact**

None of these additions (implicit messages, expanded receipts, or events) are included in snapshots. Existing chain snapshots do not contain receipts or events, and any existing system that requires receipts from snapshot data already needs to re-execute messages. This will remain the case.

**Migration strategy**

- Activation at a specific epoch through network upgrade
- Code must be updated to handle both old and new receipt formats, before and after activation epoch
- Tooling must be updated to understand the presence of implicit messages in receipts and the codec field for return data interpretation

**Migration details**

No state migration is necessary; migration exists entirely within a node implementation external to message execution and relates to the handling of tipsets executed before and after the activation epoch and the consistent generation of block headers and their immediate child components.

- For all epochs before this change is activated, `MessageReceipt` will not contain a link to the executed message or return data codec, `length(deduped parent messages) == length(receipts)` will be true, and implicit messages and their events will not be accessible
- For all epochs after this change is activated, `MessageReceipt` will contain a link to the executed message and return data codec, `length(deduped parent messages) != length(receipts)` will be true, and implicit messages along with their events will be accessible (a node may choose to not persist any events after execution, as is the case today)

## Test Cases

The following test scenarios should be implemented:

1. **Stable CID verification**:
   - Generate implicit messages using reference code
   - Verify CIDs match expected values across implementations
   - Test with various reward parameters and epoch values

2. **Null round handling**:
   - Create test chains with 1, 2, and 5 null rounds
   - Verify correct number and ordering of cron messages
   - Validate message execution matches expected order

3. **Event capture testing**:
   - Create test chain including sector termination events
   - Verify events are properly captured in receipts
   - Compare event data with expected state changes

4. **Return data codec testing**:
   - Test different actor message returns with various codecs
   - Verify codec is correctly passed through to receipt

5. **Backward compatibility**:
   - Test receipt parsing across pre/post upgrade boundary
   - Ensure proper handling of receipts without message links or codec field
   - Verify chain walk across version boundary

6. **Receipt iteration**:
   - Test message retrieval APIs with implicit messages present
   - Verify filtering capabilities for explicit vs implicit messages
   - Test receipt counts vs message counts across tipsets

## Security Considerations

This change has minimal security implications as it primarily affects event tracking and visibility. Key considerations:

1. **Consensus Safety**: The change must be activated simultaneously across all nodes to maintain consensus
2. **Resource Usage**: While the direct message size impact is modest, the cumulative effect including blockstore indexing overhead requires careful consideration
3. **Performance Impact**: The additional processing to handle implicit messages and codec information is negligible

The change does not introduce new attack vectors or modify existing security properties of the protocol.

## Incentive Considerations

This FIP has positive incentive implications:

1. **Storage Provider Benefits**: Improved sector lifecycle insights unlock additional opportunities to sell and market PoRep
2. **Tool Developer Incentives**: Simplified access to system events encourages development of better monitoring and analysis tools
3. **Network Transparency**: Increased visibility into system operations improves trust and participation
4. **Developer Experience**: Proper return value decoding reduces friction in building applications on Filecoin

Note that all of these positive impacts accrue to the network as a whole.

Negative impacts from this change include:

1. **Network-version Based Tipset Decoding**: Given the `MessageReceipt` changes and `length(deduped parent messages) != length(receipts)` difference, complexity is introduced in node implementations that attempt to retain compatibility across the upgrade boundary
2. **Block Storage Increase**: The additional storage requirements, while modest in direct size, accumulate over time and include blockstore indexing overhead

## Product Considerations

This change significantly improves the developer and user experience:

1. **Enhanced Observability**: Complete visibility into sector lifecycles and system operations
2. **Simplified Tooling**: Eliminates need for complex state diff analysis and message deduplication
3. **Better APIs**: External services can provide more comprehensive blockchain data and properly decoded return values
4. **Improved Debugging**: System operations become traceable through standard event mechanisms

This enables development of more sophisticated storage management tools and improved monitoring solutions. Specific product improvements include:

- Storage providers can build better dashboards for sector lifecycle management
- Chain explorers can show complete system operations including automatic processes and correctly formatted return values
- Analytics platforms can provide comprehensive sector health metrics
- Simplified verification of which messages were actually executed in a tipset without complex deduplication

### Improvement of the PoRep Product

Proof of Replication is a core value proposition and product of the Filecoin L1. Difficulties in inspecting and observing sector lifecycles have continued to impact the maturity of PoRep as a product. This change not only improves sector lifecycle visibility but unlocks sector lifecycle based workflows that interact with both external systems and on-chain activites via oracles.

## Implementation

Implementation requires changes to:

1. **Core protocol**:
   - Modify `MessageReceipt` structure to include message CID and IPLD codec
   - Update message execution to store implicit messages
   - Update receipt generation to link to messages and preserve codec information

2. **Tipset processing**:
   - Modify receipt iteration to handle implicit messages
   - Update validation logic for parent receipts

3. **API layer**:
   - Update message retrieval methods to handle implicit messages
   - Add filtering options for explicit vs implicit messages
   - Update return data handling to use codec information for proper decoding

4. **FVM changes**:
   - Preserve IPLD codec information during execution
   - Pass codec to message receipt generation

Note that FVM changes are not consensus-critical and can be performed prior to this upgrade. Encoding the IPLD codec in message receipts _is_ consensus-critical so network version branching simply needs to decide whether or not to encode the codec field in the receipt.

* Lotus PR (TODO)
* Forest PR (TODO)

## Open Questions

Non-consensus-critical questions that are not yet answered by this FIP but may be considered during or after implementation:

* **API Behaviour**: Should implicit messages be exposed by default or require specific flags in message-fetching APIs like `ChainGetMessagesInTipset`?
* **Ethereum API Compatibility**: How should Filecoin Ethereum-compatible APIs (`EthGetBlockTransactionCountBy*`, `EthGetTransaction*`, `EthGetBlockReceipts`) handle implicit messages? Should they be excluded to maintain compatibility or included with special identifiers?
* **Filtering Mechanisms**: What standard filtering mechanisms should be provided to distinguish between user messages and system implicit messages?

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).