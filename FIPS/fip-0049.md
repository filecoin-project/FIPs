---
fip: "0049"
title: Actor events
author: Ra√∫l Kripalani (@raulk), Steven Allen (@stebalien)
discussions-to: https://github.com/filecoin-project/FIPs/discussions/484
status: Draft
type: Technical Core
category: Core
created: 2022-10-12
spec-sections: 
  - https://spec.filecoin.io/#section-systems.filecoin_vm.runtime.receipts
requires: N/A
replaces: N/A
---

# Actor events

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Simple Summary](#simple-summary)
- [Abstract](#abstract)
- [Change Motivation](#change-motivation)
- [Specification](#specification)
  - [New chain types](#new-chain-types)
  - [Chain commitment](#chain-commitment)
  - [New `vm::emit_event` syscall](#new-vmemit_event-syscall)
  - [Gas costs](#gas-costs)
  - [Mapping to EVM logs](#mapping-to-evm-logs)
- [Design Rationale](#design-rationale)
- [Backwards Compatibility](#backwards-compatibility)
- [Test Cases](#test-cases)
- [Security Considerations](#security-considerations)
- [Incentive Considerations](#incentive-considerations)
- [Product Considerations](#product-considerations)
  - [Required for EVM compatibility](#required-for-evm-compatibility)
  - [Built-in actors observability](#built-in-actors-observability)
- [Implementation](#implementation)
  - [Reference implementation](#reference-implementation)
  - [Client handling](#client-handling)
- [Copyright](#copyright)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Simple Summary

This FIP adds the ability for actors to emit externally observable events during
execution. Events are fire-and-forget, and can be thought of as a side effect
from execution. The payloads of events are self-describing objects signaling
that some relevant circumstance, action or transition has ocurred. Actor events
enable external agents to observe the activity on chain, and may eventually
become the source of internal message triggers.

## Abstract

This FIP introduces a _minimal_ design for actor events, including their schema,
a new syscall, a new field in the `MessageReceipt` structure, and mechanics to
commit these execution side effects on the chain. By _minimal_ we mean that the
protocol stays largely unopinionated and unprescriptive around higher level
concerns like event indexing, traversal, and proofs (e.g. inclusion proofs for
light clients), and other future higher-level features.

## Change Motivation

Two main motivations warrant the introduction of actor events at this time.

1. They have been long missing from the protocol, complicating observability and
   forcing Filecoin network monitoring or accounting tools resort to creative
   approaches to obtain the data they needed, e.g. forking and instrumenting
   built-in actors code, or replaying messages and performing state tree diffs.
   
   While this may have been tolerable while the system had a limited number of
   actors, such approaches will no longer scale in a world of discretionary
   programs on chain.
   
   A future FIP could enhance built-in actors to emit events when power changes,
   sectors are onboarded, deals are made, sectors are terminated, penalties are
   incurred, etc.

2. The upcoming introduction of the Filecoin Ethereum Virtual Machine (FEVM)
   runtime necessitates an event mechanism at the protocol layer to handle the
   `LOG{0..4}` EVM opcodes, and the subsequent serving of such data through
   external JSON-RPC methods exposed by the client.

## Specification

### New chain types

We introduce a [DAG-CBOR] encoded `StampedEvent` type to represent an actor
event as committed on chain.

```rust
/// Represents an event emitted throughout message execution, stamped by the FVM
/// with additional metadata.
struct StampedEvent {
    /// Carries the actor ID of the emitting actor (stamped by the FVM).
    emitter: u64,
    /// Payload of the event, as emitted by the actor.
    event: ActorEvent,
}

/// An event as emitted by the actor.
struct ActorEvent {
    /// The key-value entries that make up the event.
    entries: [Entry],
}

struct Entry {
    /// A bitmap conveying metadata or hints about this entry.
    flags: u64,
    /// The key of this event.
    key: String,
    /// Any DAG-CBOR encodeable type.
    value: any,
}
```

Its main constituent is a list of ordered key-value **entries**. This approach
is inspired by structured logging concepts. **Keys** are strings, while
**values** can be any DAG-CBOR encodeable type.

Every **entry** contains a u64 **flags** bitmap, which conveys metadata or hints
about the entry. These are the currently supported flags:

| hex    | binary      | meaning          |
|--------|-------------|------------------|
| `0x01` | `b00000001` | indexed by key   |
| `0x02` | `b00000010` | indexed by value |

Flags are additive, such that value 0x03 (`b00000011`) indicates that the entry
must be indexed by both key and value.

These flags are only used as a client hint. In the future, this flag and others
may lead to consensus-relevant outcomes, such as populating (adaptable) bloom
filters, committing block-level indices, supporting on-chain event
subscriptions, special type indicators (e.g. "value is an address"), and more.

Note: DAG-CBOR encoding guarantees that flags with up to 4 bits will be
minimally encoded as a single byte (major type 0, with inlined value in
additional data).

Choosing a _list of tuples_ instead of a map representation is deliberate, as it
enables undistinguished repeatable keys, and, thus, array-like entries, e.g.
signers in a multisig transaction.

Over time, we expect the community to standardise on a set of keys through FRC
proposals.

**Event examples**

The following examples demonstrate how to use these structures in practice.
Payloads are DAG-CBOR encoded types.

_Fungible token transfer_

```rust
Event {
    emitter: 1260,
    entries: [ // type, sender, receiver indexed
        (0x03, "type", "transfer"),
        (0x03, "sender", <actor id>),
        (0x03, "receiver", <actor id>),
        (0x00, "amount", <token amount in atto precision>),
    ],
}
```

_Non-fungible token transfer_

```rust
Event {
    emitter: 101,
    entries: [  // all entries indexed, with type as key
        (0x01, "transfer", null),
        (0x03, "sender", <actor id>),
        (0x03, "receiver", <actor id>),
        (0x03, "token_id", <internal identifier>),
    ],
}
```

_Multisig approval_

```rust
Event {
    emitter: 1678,
    entries: [  // type and signers indexed
        (0x03, "type", "approval"),
        (0x03, "signer", <actor id>),
        (0x03, "signer", <actor id>),
        (0x03, "signer", <actor id>),
        (0x00, "callee", <actor id>),
        (0x00, "amount", <token amount>),
        (0x00, "msg_cid", <message cid>),
    ],
}
```

### Chain commitment

The existing `MessageReceipt` chain data structure is augmented with a new
`events` field:

```rust
struct MessageReceipt {
    exit_code: ExitCode,
    return_data: RawBytes,
    gas_used: i64,
    events: Cid, // new field; root of AMT<Event>
}
```

During message call stack execution, DAG-CBOR encoded `Event`s are accumulated
within the FVM inside an AMT, preserving the insertion order. At the end of
message execution, the AMT is flushed into the FVM's (buffered) blockstore, and
the root CID of the AMT is returned in the above `events` field.

Because the network agrees on the content of the receipts through the
`ParentMessageReceipts` on the `BlockHeader`, the events are implicitly
committed to the chain state with no futher structural changes needed.

### New `vm::emit_event` syscall

We define a new syscall under the `vm` namespace so that actors can emit events.

```rust
/// Emits a block as an actor event. It takes the block ID of a block created via
/// ipld::block_create. The block must be a DAG-CBOR encoded Vec<Entry>.
/// 
/// The FVM will validate the structural, syntatic, and semantic correctness of the
/// supplied payload, and will error with `IllegalArgument` if the payload was invalid.
///
/// Calling this syscall may immediately halt execution with an out of gas error, if
/// such condition arises.
fn emit_event(entries_id: u32) -> Result<()>;
```

This syscall will create an `Event` object, stamp it with the current ActorID,
and store it in the events accumulator.

We expect FVM SDKs to offer utilities, macros, and sugar to ergonomically
construct event payloads and handle the IPLD block creation task.

### Gas costs

In addition to the [syscall gas cost], emitting an event carries the following
dynamic costs:

- Per non-indexed entry: <<TODO>> gas per <<TODO>>.
- Per indexed entry: <<TODO>> gas per <<TODO>>.

> TODO need to make syscall gas dynamic based on param length

The following limits apply. Exceeding these limits will result in the event not
being emitted, and the call failing with the `IllegalArgument` error number:

> - Total event payload size: <<TODO, if any; may be bound by gas, once syscall
>   gas varies based on param length?>>
> - Maximum number of keys: <<TODO, if any; may be bound by gas>>
> - Maximum number of indexed keys: <<TODO, if any; may be bound by gas>>
> - Maximum `key` length: 256 bytes.
> - Maximum `value` length: 256 bytes.

### Mapping to EVM logs

Refer to FIP-0054.

## Design Rationale

A large part of the architectural discussion has been documented in issue
[filecoin-project/ref-fvm#728]. Some ideas we considered along the way included:

- Keeping events away from the protocol and in actor land, by tracking them in
  an Events actor.
- Populating event indices and committing them on the block header.
- Adaptable bloom filters, advertised on the block header.
- Wrapping events in a broader concept of "execution artifacts", which in the
  future could be extended to include callbacks, futures, and more.

We deferred most ideas to the future and kept this initial proposal simple, yet
extensible, focusing only on the fundamentals. A particular area to conduct
further research into is Filecoin light clients and the kinds of proofs that
could endorse queries for events, including inclusion, non-inclusion, and
completeness proofs.

In terms of the technical design, we considered making the event payload an
opaque IPLD blob accompanied by some form of a type discriminator. However, that
would require an IDL upfront to interpret the payload. We posit that the
unwrapped data model we've proposed enables straightforward introspection and
comprehension by chain explorers, developer tools, and monitoring tools.

Concerning the concept of `flags`, we had initially considered a top-level
`indexed` bitmap, but later generalised it to a `flags` field for extensibility.
We consider the consequent size tradeoff to be acceptable.

## Backwards Compatibility

We are adding a new field to the `MessageReceipt` type. While this type is not
serialized over the wire nor gossiped, it is returned from JSON-RPC calls.
Hence, users of Filecoin clients may notice a new field, which could in turn
break some of their code.

## Test Cases

TODO.

## Security Considerations

TODO.

## Incentive Considerations

No incentive considerations apply.

## Product Considerations

### Required for EVM compatibility

Even though we've been seeking to introduce on-chain observability for some time
now, we explicitly recognize that the immediate motivation is EVM compatibility.

### Built-in actors observability

Upcoming network versions should strive to update built-in actors to emit actor
events for meaningful transitions and circumstances. This would allow
observability, monitoring, accounting and other external tools to stop depending
on highly-coupled, internal and low-level mechanisms to source information, such
as state replays, state diffs, execution traces, and others.

A project tackling this mission should begin by inventorizing all situations
that would emit events, designing the events, projecting the cost, and
prioritizing their implementation together with the community. There is likely a
sweet spot that strikes the optimal balance between value and cost.

## Implementation

### Reference implementation

The reference implementation is being carried out under
[`filecoin-project/ref-fvm`], and its first adoption is within the EVM runtime
actor under [`filecoin-project/builtin-actors`].

### Client handling

Honouring indexing hints is optional but highly encouraged at this stage.
Clients may offer new JSON-RPC operations to subscribe to and query events.

Clients may prefer to store and track event data in a dedicated store,
segregated from the chain store, potentially backed by a different database
engine more suited to the expected write, query, and indexing patterns for this
data.

Note that there's a timing difference between the moment the client receives the
events AMT root CID (after message execution), and the moment that the event
data (IPLD blocks) is effectively made available in the client's blockstore (at
Machine flush time). Consequently, events cannot be viewed/logged/inspected
until the Machine is flushed.

FVM implementations may accept a separate events store, and offer an "early
events flush" Machine option to instruct the FVM to flush events on every
message execution.

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).


[`filecoin-project/builtin-actors`]: https://github.com/filecoin-project/builtin-actors
[`filecoin-project/ref-fvm`]: https://github.com/filecoin-project/ref-fvm
[`MessageReceipt` type]: https://spec.filecoin.io/#section-systems.filecoin_vm.message.message-semantic-validation
[syscall gas cost]: https://github.com/filecoin-project/FIPs/blob/master/FIPS/fip-0032.md#syscall-gas
[filecoin-project/ref-fvm#728]: https://github.com/filecoin-project/ref-fvm/issues/728
[DAG-CBOR]: https://github.com/ipld/specs/blob/master/block-layer/codecs/dag-cbor.md